#!/usr/bin/env node

/**
 * Ï†ÑÏ≤¥ Íµ≠ÌÜ†Î∂Ä Ïã§Í±∞ÎûòÍ∞Ä Îç∞Ïù¥ÌÑ∞(20,777Í∞ú Îã®ÏßÄ)Î•º Í∏∞Î∞òÏúºÎ°ú Ìïú ÌÜµÌï© DB Íµ¨Ï∂ï
 * 
 * Îç∞Ïù¥ÌÑ∞ ÌùêÎ¶Ñ:
 * 1. Íµ≠ÌÜ†Î∂Ä Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ (977,388Í∞ú Í±∞Îûò, 20,777Í∞ú Îã®ÏßÄ) Ï∂îÏ∂ú
 * 2. ÏïÑÌååÌä∏ Îã®ÏßÄÎ≥Ñ Í∑∏Î£πÌïë Î∞è ÌÜµÍ≥Ñ ÏÉùÏÑ±
 * 3. ÎÑ§Ïù¥Î≤Ñ ÌÅ¨Î°§ÎßÅ Îç∞Ïù¥ÌÑ∞ Îß§Ïπ≠
 * 4. ÌÜµÌï© Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Íµ¨Ï∂ï
 */

const sqlite3 = require('sqlite3').verbose()
const path = require('path')
const fs = require('fs')

class FullMolitIntegration {
  constructor() {
    this.molitDbPath = '/Users/seongjunkim/projects/real-estate-platform/molit_complete_data.db'
    this.naverDbPath = '/Users/seongjunkim/projects/real-estate-platform/modules/naver-crawler/data/naver_crawled_data.db'
    this.outputDbPath = '/Users/seongjunkim/projects/real-estate-platform/api/data/full_integrated_real_estate.db'
    
    this.stats = {
      total_transactions: 0,
      unique_complexes: 0,
      matched_naver_complexes: 0,
      created_complexes: 0,
      created_transactions: 0,
      errors: []
    }
  }

  async run() {
    console.log('üèóÔ∏è  Íµ≠ÌÜ†Î∂Ä Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò ÌÜµÌï© DB Íµ¨Ï∂ï ÏãúÏûë')
    console.log('=' .repeat(60))
    
    try {
      // 1. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞
      await this.connectDatabases()
      
      // 2. Ï∂úÎ†• DB Ïä§ÌÇ§Îßà ÏÉùÏÑ±
      await this.createIntegratedSchema()
      
      // 3. Íµ≠ÌÜ†Î∂Ä Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏïÑÌååÌä∏ Îã®ÏßÄ Ï∂îÏ∂ú
      await this.extractComplexesFromMolit()
      
      // 4. Íµ≠ÌÜ†Î∂Ä Í±∞Îûò Îç∞Ïù¥ÌÑ∞ Ïó∞Í≤∞
      await this.linkMolitTransactions()
      
      // 5. ÎÑ§Ïù¥Î≤Ñ ÌÅ¨Î°§ÎßÅ Îç∞Ïù¥ÌÑ∞ Îß§Ïπ≠
      await this.matchNaverData()
      
      // 6. ÌÅ¨Î°§ÎßÅ Ïö∞ÏÑ†ÏàúÏúÑ ÌÅê ÏÉùÏÑ±
      await this.createCrawlingQueue()
      
      // 7. ÌÜµÍ≥Ñ Î∞è Ïù∏Îç±Ïä§ ÏÉùÏÑ±
      await this.createStatisticsAndIndexes()
      
      // 8. Í≤∞Í≥º Ï∂úÎ†•
      this.printResults()
      
    } catch (error) {
      console.error('‚ùå Ïò§Î•ò Î∞úÏÉù:', error)
      this.stats.errors.push(error.message)
    } finally {
      await this.closeDatabases()
    }
  }

  async connectDatabases() {
    console.log('üì° Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï§ë...')
    
    return new Promise((resolve, reject) => {
      // Íµ≠ÌÜ†Î∂Ä DB Ïó∞Í≤∞
      this.molitDb = new sqlite3.Database(this.molitDbPath, sqlite3.OPEN_READONLY, (err) => {
        if (err) {
          reject(new Error(`Íµ≠ÌÜ†Î∂Ä DB Ïó∞Í≤∞ Ïã§Ìå®: ${err.message}`))
          return
        }
        
        // ÎÑ§Ïù¥Î≤Ñ DB Ïó∞Í≤∞
        this.naverDb = new sqlite3.Database(this.naverDbPath, sqlite3.OPEN_READONLY, (err) => {
          if (err) {
            console.warn(`‚ö†Ô∏è  ÎÑ§Ïù¥Î≤Ñ DB Ïó∞Í≤∞ Ïã§Ìå® (ÏÑ†ÌÉùÏÇ¨Ìï≠): ${err.message}`)
          }
          
          // Ï∂úÎ†• DB Ïó∞Í≤∞
          this.outputDb = new sqlite3.Database(this.outputDbPath, (err) => {
            if (err) {
              reject(new Error(`Ï∂úÎ†• DB Ïó∞Í≤∞ Ïã§Ìå®: ${err.message}`))
              return
            }
            
            console.log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏôÑÎ£å')
            resolve()
          })
        })
      })
    })
  }

  async createIntegratedSchema() {
    console.log('üèóÔ∏è  ÌÜµÌï© DB Ïä§ÌÇ§Îßà ÏÉùÏÑ± Ï§ë...')
    
    const schema = `
      -- ÏïÑÌååÌä∏ Îã®ÏßÄ ÌÖåÏù¥Î∏î
      CREATE TABLE IF NOT EXISTS apartment_complexes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        complex_key TEXT UNIQUE NOT NULL, -- region|dong|aptName Ï°∞Ìï©
        sigungu TEXT NOT NULL,
        eup_myeon_dong TEXT NOT NULL,
        apartment_name TEXT NOT NULL,
        road_name TEXT,
        road_number TEXT,
        land_number TEXT,
        
        -- ÌÜµÍ≥Ñ Ï†ïÎ≥¥
        total_transactions INTEGER DEFAULT 0,
        avg_price_per_pyeong INTEGER,
        latest_transaction_date TEXT,
        price_trend TEXT, -- 'rising', 'falling', 'stable'
        
        -- ÎÑ§Ïù¥Î≤Ñ Îß§Ïπ≠ Ï†ïÎ≥¥
        naver_complex_id TEXT,
        naver_matched_at DATETIME,
        has_naver_data BOOLEAN DEFAULT 0,
        
        -- ÌÅ¨Î°§ÎßÅ Í¥ÄÎ†®
        crawling_priority INTEGER DEFAULT 0, -- Í±∞ÎûòÎüâ Í∏∞Î∞ò Ïö∞ÏÑ†ÏàúÏúÑ
        crawling_status TEXT DEFAULT 'pending', -- pending, in_progress, completed, failed
        
        -- Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
        source_type TEXT DEFAULT 'molit',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- Ïã§Í±∞ÎûòÍ∞Ä Í∏∞Î°ù ÌÖåÏù¥Î∏î
      CREATE TABLE IF NOT EXISTS transaction_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        complex_id INTEGER REFERENCES apartment_complexes(id),
        
        -- Í±∞Îûò Ï†ïÎ≥¥
        deal_amount INTEGER NOT NULL, -- ÎßåÏõê Îã®ÏúÑ
        deal_date TEXT NOT NULL, -- YYYY-MM
        area_for_exclusive_use REAL, -- Ï†ÑÏö©Î©¥Ï†Å
        floor INTEGER,
        construction_year INTEGER,
        
        -- ÏúÑÏπò Ï†ïÎ≥¥
        sigungu TEXT NOT NULL,
        eup_myeon_dong TEXT NOT NULL,
        apartment_name TEXT NOT NULL,
        
        -- ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞
        raw_data TEXT, -- JSON ÌòïÌÉúÎ°ú Ï†ÄÏû•
        
        -- Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
        source_type TEXT DEFAULT 'molit',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- ÌòÑÏû¨ Îß§Î¨º ÌÖåÏù¥Î∏î (ÎÑ§Ïù¥Î≤ÑÏóêÏÑú Í∞ÄÏ†∏Ïò® Îç∞Ïù¥ÌÑ∞)
      CREATE TABLE IF NOT EXISTS current_listings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        complex_id INTEGER REFERENCES apartment_complexes(id),
        
        -- Îß§Î¨º Ï†ïÎ≥¥
        listing_price INTEGER, -- Îß§Îß§Í∞Ä (ÎßåÏõê)
        monthly_rent INTEGER, -- ÏõîÏÑ∏ (ÎßåÏõê)
        deposit INTEGER, -- Ï†ÑÏÑ∏/Î≥¥Ï¶ùÍ∏à (ÎßåÏõê)
        area_pyeong REAL, -- ÌèâÏàò
        area_sqm REAL, -- Ï†úÍ≥±ÎØ∏ÌÑ∞
        floor_info TEXT, -- Ï∏µÏàò Ï†ïÎ≥¥
        
        -- Îß§Î¨º ÏÉÅÏÑ∏
        listing_type TEXT, -- 'sale', 'jeonse', 'monthly'
        description TEXT,
        listing_url TEXT,
        
        -- Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
        source_type TEXT DEFAULT 'naver',
        crawled_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- ÌÅ¨Î°§ÎßÅ ÌÅê ÌÖåÏù¥Î∏î
      CREATE TABLE IF NOT EXISTS crawling_queue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        complex_id INTEGER REFERENCES apartment_complexes(id),
        priority INTEGER NOT NULL, -- 1(highest) to 10(lowest)
        status TEXT DEFAULT 'pending', -- pending, in_progress, completed, failed
        
        -- ÌÅ¨Î°§ÎßÅ Ï†ïÎ≥¥
        target_type TEXT NOT NULL, -- 'complex_info', 'current_listings'
        retry_count INTEGER DEFAULT 0,
        last_attempt_at DATETIME,
        completed_at DATETIME,
        error_message TEXT,
        
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- ÌÜµÍ≥Ñ ÌÖåÏù¥Î∏î
      CREATE TABLE IF NOT EXISTS complex_statistics (
        complex_id INTEGER PRIMARY KEY REFERENCES apartment_complexes(id),
        
        -- Í∞ÄÍ≤© ÌÜµÍ≥Ñ
        min_price INTEGER,
        max_price INTEGER,
        avg_price INTEGER,
        median_price INTEGER,
        price_per_pyeong INTEGER,
        
        -- Í±∞ÎûòÎüâ ÌÜµÍ≥Ñ
        total_transactions INTEGER,
        transactions_last_year INTEGER,
        transactions_last_month INTEGER,
        
        -- Î©¥Ï†Å ÌÜµÍ≥Ñ
        min_area REAL,
        max_area REAL,
        avg_area REAL,
        
        -- Í∏∞ÌÉÄ ÌÜµÍ≥Ñ
        construction_year INTEGER,
        building_count INTEGER,
        household_count INTEGER,
        
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- ÎÑ§Ïù¥Î≤Ñ Îß§Ïπ≠ Îß§Ìïë ÌÖåÏù¥Î∏î
      CREATE TABLE IF NOT EXISTS naver_complex_mapping (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        complex_id INTEGER REFERENCES apartment_complexes(id),
        naver_complex_id TEXT,
        
        -- Îß§Ïπ≠ Ïã†Î¢∞ÎèÑ
        match_confidence REAL, -- 0.0 to 1.0
        match_method TEXT, -- 'exact_name', 'fuzzy_name', 'address_based'
        
        -- Îß§Ïπ≠ Ï†ïÎ≥¥
        matched_name TEXT,
        matched_address TEXT,
        
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );
    `
    
    return new Promise((resolve, reject) => {
      this.outputDb.exec(schema, (err) => {
        if (err) {
          reject(new Error(`Ïä§ÌÇ§Îßà ÏÉùÏÑ± Ïã§Ìå®: ${err.message}`))
          return
        }
        console.log('‚úÖ ÌÜµÌï© DB Ïä§ÌÇ§Îßà ÏÉùÏÑ± ÏôÑÎ£å')
        resolve()
      })
    })
  }

  async extractComplexesFromMolit() {
    console.log('üè¢ Íµ≠ÌÜ†Î∂Ä Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏïÑÌååÌä∏ Îã®ÏßÄ Ï∂îÏ∂ú Ï§ë...')
    
    const query = `
      SELECT 
        region_name as sigungu,
        JSON_EXTRACT(api_data, '$.umdNm') as eup_myeon_dong,
        JSON_EXTRACT(api_data, '$.aptNm') as apartment_name,
        JSON_EXTRACT(api_data, '$.roadNm') as road_name,
        JSON_EXTRACT(api_data, '$.roadNmCd') as road_number,
        JSON_EXTRACT(api_data, '$.jibun') as land_number,
        COUNT(*) as transaction_count,
        AVG(CAST(REPLACE(JSON_EXTRACT(api_data, '$.dealAmount'), ',', '') AS INTEGER)) as avg_price,
        MAX(JSON_EXTRACT(api_data, '$.dealYear') || '-' || 
            CASE WHEN LENGTH(JSON_EXTRACT(api_data, '$.dealMonth')) = 1 
                 THEN '0' || JSON_EXTRACT(api_data, '$.dealMonth') 
                 ELSE JSON_EXTRACT(api_data, '$.dealMonth') END) as latest_date,
        MIN(CAST(REPLACE(JSON_EXTRACT(api_data, '$.excluUseAr'), ',', '') AS REAL)) as min_area,
        MAX(CAST(REPLACE(JSON_EXTRACT(api_data, '$.excluUseAr'), ',', '') AS REAL)) as max_area,
        AVG(CAST(REPLACE(JSON_EXTRACT(api_data, '$.excluUseAr'), ',', '') AS REAL)) as avg_area
      FROM apartment_transactions 
      WHERE JSON_EXTRACT(api_data, '$.aptNm') IS NOT NULL 
        AND JSON_EXTRACT(api_data, '$.aptNm') != ''
        AND JSON_EXTRACT(api_data, '$.dealAmount') IS NOT NULL
      GROUP BY region_name, JSON_EXTRACT(api_data, '$.umdNm'), JSON_EXTRACT(api_data, '$.aptNm')
      ORDER BY transaction_count DESC
    `
    
    return new Promise((resolve, reject) => {
      this.molitDb.all(query, [], (err, rows) => {
        if (err) {
          reject(new Error(`ÏïÑÌååÌä∏ Îã®ÏßÄ Ï∂îÏ∂ú Ïã§Ìå®: ${err.message}`))
          return
        }
        
        console.log(`üìä Ï∂îÏ∂úÎêú Í≥†Ïú† Îã®ÏßÄ Ïàò: ${rows.length}Í∞ú`)
        this.stats.unique_complexes = rows.length
        
        // Î∞∞ÏπòÎ°ú Îã®ÏßÄ Ï†ïÎ≥¥ ÏÇΩÏûÖ
        this.insertComplexesBatch(rows).then(resolve).catch(reject)
      })
    })
  }

  async insertComplexesBatch(complexes) {
    console.log('üíæ ÏïÑÌååÌä∏ Îã®ÏßÄ Ï†ïÎ≥¥ DB ÏÇΩÏûÖ Ï§ë...')
    
    const stmt = this.outputDb.prepare(`
      INSERT INTO apartment_complexes (
        complex_key, sigungu, eup_myeon_dong, apartment_name,
        road_name, road_number, land_number,
        total_transactions, avg_price_per_pyeong, latest_transaction_date,
        crawling_priority, source_type
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'molit')
    `)
    
    let insertCount = 0
    const batchSize = 1000
    
    return new Promise((resolve, reject) => {
      this.outputDb.run('BEGIN TRANSACTION')
      
      for (let i = 0; i < complexes.length; i += batchSize) {
        const batch = complexes.slice(i, i + batchSize)
        
        for (const complex of batch) {
          if (!complex.apartment_name || !complex.sigungu || !complex.eup_myeon_dong) {
            continue
          }
          
          const complexKey = `${complex.sigungu}|${complex.eup_myeon_dong}|${complex.apartment_name}`
          const avgPricePerPyeong = complex.avg_area > 0 ? 
            Math.round((complex.avg_price * 10000) / (complex.avg_area * 3.3058)) : null
          
          // Í±∞ÎûòÎüâ Í∏∞Î∞ò ÌÅ¨Î°§ÎßÅ Ïö∞ÏÑ†ÏàúÏúÑ (1-10, 1Ïù¥ ÏµúÍ≥† Ïö∞ÏÑ†ÏàúÏúÑ)
          const priority = complex.transaction_count >= 100 ? 1 :
                          complex.transaction_count >= 50 ? 2 :
                          complex.transaction_count >= 20 ? 3 :
                          complex.transaction_count >= 10 ? 4 :
                          complex.transaction_count >= 5 ? 5 : 6
          
          try {
            stmt.run([
              complexKey,
              complex.sigungu,
              complex.eup_myeon_dong, 
              complex.apartment_name,
              complex.road_name,
              complex.road_number,
              complex.land_number,
              complex.transaction_count,
              avgPricePerPyeong,
              complex.latest_date,
              priority
            ])
            insertCount++
          } catch (err) {
            console.warn(`‚ö†Ô∏è  Îã®ÏßÄ ÏÇΩÏûÖ Ïã§Ìå®: ${complex.apartment_name} - ${err.message}`)
          }
        }
        
        // ÏßÑÌñâÎ•† ÌëúÏãú
        if (i % (batchSize * 5) === 0) {
          console.log(`   ÏßÑÌñâÎ•†: ${Math.round((i / complexes.length) * 100)}% (${insertCount}Í∞ú ÏÇΩÏûÖÎê®)`)
        }
      }
      
      this.outputDb.run('COMMIT', (err) => {
        stmt.finalize()
        
        if (err) {
          reject(new Error(`Î∞∞Ïπò ÏÇΩÏûÖ Ïª§Î∞ã Ïã§Ìå®: ${err.message}`))
          return
        }
        
        this.stats.created_complexes = insertCount
        console.log(`‚úÖ ÏïÑÌååÌä∏ Îã®ÏßÄ ${insertCount}Í∞ú ÏÇΩÏûÖ ÏôÑÎ£å`)
        resolve()
      })
    })
  }

  async linkMolitTransactions() {
    console.log('üîó Íµ≠ÌÜ†Î∂Ä Í±∞Îûò Îç∞Ïù¥ÌÑ∞ Ïó∞Í≤∞ Ï§ë...')
    
    // Î™®Îì† Í±∞Îûò Îç∞Ïù¥ÌÑ∞Î•º Î≥µÏÇ¨ (ÎÑàÎ¨¥ ÎßéÏúºÎØÄÎ°ú ÏÉòÌîåÎßÅ ÎòêÎäî Ï†úÌïú)
    const query = `
      SELECT 
        region_name as sigungu,
        JSON_EXTRACT(api_data, '$.umdNm') as eup_myeon_dong,
        JSON_EXTRACT(api_data, '$.aptNm') as apartment_name,
        CAST(REPLACE(JSON_EXTRACT(api_data, '$.dealAmount'), ',', '') AS INTEGER) as deal_amount,
        JSON_EXTRACT(api_data, '$.dealYear') || '-' || 
        CASE WHEN LENGTH(JSON_EXTRACT(api_data, '$.dealMonth')) = 1 
             THEN '0' || JSON_EXTRACT(api_data, '$.dealMonth') 
             ELSE JSON_EXTRACT(api_data, '$.dealMonth') END as deal_date,
        CAST(REPLACE(JSON_EXTRACT(api_data, '$.excluUseAr'), ',', '') AS REAL) as area_for_exclusive_use,
        CAST(JSON_EXTRACT(api_data, '$.floor') AS INTEGER) as floor,
        CAST(JSON_EXTRACT(api_data, '$.buildYear') AS INTEGER) as construction_year,
        api_data as raw_data
      FROM apartment_transactions 
      WHERE JSON_EXTRACT(api_data, '$.aptNm') IS NOT NULL 
        AND JSON_EXTRACT(api_data, '$.dealAmount') IS NOT NULL
      LIMIT 50000
    `
    
    return new Promise((resolve, reject) => {
      this.molitDb.all(query, [], (err, rows) => {
        if (err) {
          reject(new Error(`Í±∞Îûò Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®: ${err.message}`))
          return
        }
        
        console.log(`üìä Ïó∞Í≤∞Ìï† Í±∞Îûò Îç∞Ïù¥ÌÑ∞: ${rows.length}Í∞ú`)
        this.insertTransactionsBatch(rows).then(resolve).catch(reject)
      })
    })
  }

  async insertTransactionsBatch(transactions) {
    console.log('üíæ Í±∞Îûò Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ Ï§ë...')
    
    const stmt = this.outputDb.prepare(`
      INSERT INTO transaction_records (
        complex_id, deal_amount, deal_date, area_for_exclusive_use,
        floor, construction_year, sigungu, eup_myeon_dong, apartment_name,
        raw_data, source_type
      ) SELECT 
        ac.id, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'molit'
      FROM apartment_complexes ac 
      WHERE ac.complex_key = ?
    `)
    
    let insertCount = 0
    const batchSize = 1000
    
    return new Promise((resolve, reject) => {
      this.outputDb.run('BEGIN TRANSACTION')
      
      for (let i = 0; i < transactions.length; i += batchSize) {
        const batch = transactions.slice(i, i + batchSize)
        
        for (const tx of batch) {
          if (!tx.apartment_name || !tx.deal_amount) {
            continue
          }
          
          const complexKey = `${tx.sigungu}|${tx.eup_myeon_dong}|${tx.apartment_name}`
          
          try {
            stmt.run([
              tx.deal_amount,
              tx.deal_date,
              tx.area_for_exclusive_use,
              tx.floor,
              tx.construction_year,
              tx.sigungu,
              tx.eup_myeon_dong,
              tx.apartment_name,
              tx.raw_data,
              complexKey
            ])
            insertCount++
          } catch (err) {
            // Ï§ëÎ≥µ ÎòêÎäî Îß§Ïπ≠ Ïã§Ìå®Îäî Ï°∞Ïö©Ìûà Ï≤òÎ¶¨
          }
        }
        
        if (i % (batchSize * 5) === 0) {
          console.log(`   ÏßÑÌñâÎ•†: ${Math.round((i / transactions.length) * 100)}% (${insertCount}Í∞ú ÏÇΩÏûÖÎê®)`)
        }
      }
      
      this.outputDb.run('COMMIT', (err) => {
        stmt.finalize()
        
        if (err) {
          reject(new Error(`Í±∞Îûò Îç∞Ïù¥ÌÑ∞ Ïª§Î∞ã Ïã§Ìå®: ${err.message}`))
          return
        }
        
        this.stats.created_transactions = insertCount
        console.log(`‚úÖ Í±∞Îûò Îç∞Ïù¥ÌÑ∞ ${insertCount}Í∞ú ÏÇΩÏûÖ ÏôÑÎ£å`)
        resolve()
      })
    })
  }

  async matchNaverData() {
    console.log('üîÑ ÎÑ§Ïù¥Î≤Ñ ÌÅ¨Î°§ÎßÅ Îç∞Ïù¥ÌÑ∞ Îß§Ïπ≠ Ï§ë...')
    
    if (!this.naverDb) {
      console.log('‚ö†Ô∏è  ÎÑ§Ïù¥Î≤Ñ DBÍ∞Ä ÏóÜÏñ¥ Îß§Ïπ≠ Í±¥ÎÑàÎúÄ')
      return
    }
    
    // ÎÑ§Ïù¥Î≤Ñ Îã®ÏßÄ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
    const query = `SELECT complex_id, complex_name, address FROM apartment_complexes`
    
    return new Promise((resolve, reject) => {
      this.naverDb.all(query, [], (err, naverComplexes) => {
        if (err) {
          console.warn(`‚ö†Ô∏è  ÎÑ§Ïù¥Î≤Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®: ${err.message}`)
          resolve()
          return
        }
        
        console.log(`üìä ÎÑ§Ïù¥Î≤Ñ Îã®ÏßÄ Îç∞Ïù¥ÌÑ∞: ${naverComplexes.length}Í∞ú`)
        
        // Îß§Ïπ≠ Î°úÏßÅ Ïã§Ìñâ
        this.performNaverMatching(naverComplexes).then(resolve).catch(reject)
      })
    })
  }

  async performNaverMatching(naverComplexes) {
    let matchCount = 0
    
    const updateStmt = this.outputDb.prepare(`
      UPDATE apartment_complexes 
      SET naver_complex_id = ?, has_naver_data = 1, naver_matched_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `)
    
    const insertMappingStmt = this.outputDb.prepare(`
      INSERT INTO naver_complex_mapping (complex_id, naver_complex_id, match_confidence, match_method, matched_name)
      VALUES (?, ?, ?, ?, ?)
    `)
    
    return new Promise((resolve, reject) => {
      // ÌÜµÌï© DBÏùò Î™®Îì† Îã®ÏßÄ Ï°∞Ìöå
      this.outputDb.all(`SELECT id, apartment_name, sigungu, eup_myeon_dong FROM apartment_complexes`, [], (err, molitComplexes) => {
        if (err) {
          reject(new Error(`ÌÜµÌï© Îã®ÏßÄ Ï°∞Ìöå Ïã§Ìå®: ${err.message}`))
          return
        }
        
        console.log(`üîç ${molitComplexes.length}Í∞ú Îã®ÏßÄÏóê ÎåÄÌï¥ ÎÑ§Ïù¥Î≤Ñ Îß§Ïπ≠ ÏãúÎèÑ`)
        
        this.outputDb.serialize(() => {
          this.outputDb.run('BEGIN TRANSACTION')
          
          for (const molitComplex of molitComplexes) {
          // Ï†ïÌôïÌïú Ïù¥Î¶Ñ Îß§Ïπ≠
          const exactMatch = naverComplexes.find(nc => 
            nc.complex_name === molitComplex.apartment_name
          )
          
          if (exactMatch) {
            updateStmt.run([exactMatch.complex_id, molitComplex.id])
            insertMappingStmt.run([
              molitComplex.id, 
              exactMatch.complex_id, 
              1.0, 
              'exact_name', 
              exactMatch.complex_name
            ])
            matchCount++
            continue
          }
          
          // Ïú†ÏÇ¨Ìïú Ïù¥Î¶Ñ Îß§Ïπ≠ (Í∞ÑÎã®Ìïú Ìè¨Ìï® Í¥ÄÍ≥Ñ)
          const fuzzyMatch = naverComplexes.find(nc => 
            nc.complex_name.includes(molitComplex.apartment_name) ||
            molitComplex.apartment_name.includes(nc.complex_name)
          )
          
          if (fuzzyMatch) {
            updateStmt.run([fuzzyMatch.complex_id, molitComplex.id])
            insertMappingStmt.run([
              molitComplex.id, 
              fuzzyMatch.complex_id, 
              0.8, 
              'fuzzy_name', 
              fuzzyMatch.complex_name
            ])
            matchCount++
          }
        }
        
          this.outputDb.run('COMMIT', (err) => {
            updateStmt.finalize()
            insertMappingStmt.finalize()
            
            if (err) {
              reject(new Error(`ÎÑ§Ïù¥Î≤Ñ Îß§Ïπ≠ Ïª§Î∞ã Ïã§Ìå®: ${err.message}`))
              return
            }
            
            this.stats.matched_naver_complexes = matchCount
            console.log(`‚úÖ ÎÑ§Ïù¥Î≤Ñ Îç∞Ïù¥ÌÑ∞ ${matchCount}Í∞ú Îã®ÏßÄ Îß§Ïπ≠ ÏôÑÎ£å`)
            resolve()
          })
        })
      })
    })
  }

  async createCrawlingQueue() {
    console.log('üìã ÌÅ¨Î°§ÎßÅ Ïö∞ÏÑ†ÏàúÏúÑ ÌÅê ÏÉùÏÑ± Ï§ë...')
    
    const query = `
      INSERT INTO crawling_queue (complex_id, priority, target_type)
      SELECT 
        id,
        crawling_priority,
        'complex_info'
      FROM apartment_complexes 
      WHERE has_naver_data = 0
      ORDER BY crawling_priority ASC, total_transactions DESC
    `
    
    return new Promise((resolve, reject) => {
      this.outputDb.run(query, [], function(err) {
        if (err) {
          reject(new Error(`ÌÅ¨Î°§ÎßÅ ÌÅê ÏÉùÏÑ± Ïã§Ìå®: ${err.message}`))
          return
        }
        
        console.log(`‚úÖ ÌÅ¨Î°§ÎßÅ ÌÅê ${this.changes}Í∞ú Ìï≠Î™© ÏÉùÏÑ± ÏôÑÎ£å`)
        resolve()
      })
    })
  }

  async createStatisticsAndIndexes() {
    console.log('üìä ÌÜµÍ≥Ñ Î∞è Ïù∏Îç±Ïä§ ÏÉùÏÑ± Ï§ë...')
    
    const operations = [
      // ÌÜµÍ≥Ñ ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
      `INSERT OR REPLACE INTO complex_statistics (
        complex_id, min_price, max_price, avg_price, total_transactions,
        min_area, max_area, avg_area, updated_at
      )
      SELECT 
        ac.id,
        MIN(tr.deal_amount) as min_price,
        MAX(tr.deal_amount) as max_price,
        AVG(tr.deal_amount) as avg_price,
        COUNT(tr.id) as total_transactions,
        MIN(tr.area_for_exclusive_use) as min_area,
        MAX(tr.area_for_exclusive_use) as max_area,
        AVG(tr.area_for_exclusive_use) as avg_area,
        CURRENT_TIMESTAMP
      FROM apartment_complexes ac
      LEFT JOIN transaction_records tr ON ac.id = tr.complex_id
      GROUP BY ac.id`,
      
      // Ïù∏Îç±Ïä§ ÏÉùÏÑ±
      `CREATE INDEX IF NOT EXISTS idx_complexes_key ON apartment_complexes(complex_key)`,
      `CREATE INDEX IF NOT EXISTS idx_complexes_location ON apartment_complexes(sigungu, eup_myeon_dong)`,
      `CREATE INDEX IF NOT EXISTS idx_complexes_priority ON apartment_complexes(crawling_priority)`,
      `CREATE INDEX IF NOT EXISTS idx_transactions_complex ON transaction_records(complex_id)`,
      `CREATE INDEX IF NOT EXISTS idx_transactions_date ON transaction_records(deal_date)`,
      `CREATE INDEX IF NOT EXISTS idx_listings_complex ON current_listings(complex_id)`,
      `CREATE INDEX IF NOT EXISTS idx_crawling_queue_priority ON crawling_queue(priority, status)`,
    ]
    
    for (const operation of operations) {
      await new Promise((resolve, reject) => {
        this.outputDb.run(operation, [], (err) => {
          if (err) {
            console.warn(`‚ö†Ô∏è  ÏûëÏóÖ Ïã§Ìå®: ${err.message}`)
          }
          resolve()
        })
      })
    }
    
    console.log('‚úÖ ÌÜµÍ≥Ñ Î∞è Ïù∏Îç±Ïä§ ÏÉùÏÑ± ÏôÑÎ£å')
  }

  async closeDatabases() {
    return new Promise((resolve) => {
      let closed = 0
      const total = 3
      
      const checkComplete = () => {
        closed++
        if (closed === total) resolve()
      }
      
      if (this.molitDb) {
        this.molitDb.close(checkComplete)
      } else {
        checkComplete()
      }
      
      if (this.naverDb) {
        this.naverDb.close(checkComplete)
      } else {
        checkComplete()
      }
      
      if (this.outputDb) {
        this.outputDb.close(checkComplete)
      } else {
        checkComplete()
      }
    })
  }

  printResults() {
    console.log('\nüéâ ÌÜµÌï© DB Íµ¨Ï∂ï ÏôÑÎ£å!')
    console.log('=' .repeat(60))
    console.log(`üìä Ï≤òÎ¶¨ Í≤∞Í≥º:`)
    console.log(`   ‚Ä¢ Ï∂îÏ∂úÎêú Í≥†Ïú† Îã®ÏßÄ: ${this.stats.unique_complexes.toLocaleString()}Í∞ú`)
    console.log(`   ‚Ä¢ ÏÉùÏÑ±Îêú Îã®ÏßÄ: ${this.stats.created_complexes.toLocaleString()}Í∞ú`)
    console.log(`   ‚Ä¢ ÏÉùÏÑ±Îêú Í±∞Îûò Í∏∞Î°ù: ${this.stats.created_transactions.toLocaleString()}Í∞ú`)
    console.log(`   ‚Ä¢ ÎÑ§Ïù¥Î≤Ñ Îß§Ïπ≠ Îã®ÏßÄ: ${this.stats.matched_naver_complexes.toLocaleString()}Í∞ú`)
    
    if (this.stats.errors.length > 0) {
      console.log(`\n‚ö†Ô∏è  Ïò§Î•ò ${this.stats.errors.length}Í∞ú:`)
      this.stats.errors.forEach(error => console.log(`   ‚Ä¢ ${error}`))
    }
    
    console.log(`\nüíæ Ï∂úÎ†• DB: ${this.outputDbPath}`)
    console.log('üéØ Îã§Ïùå Îã®Í≥Ñ: ÎÑ§Ïù¥Î≤Ñ ÌÅ¨Î°§ÎßÅ Ïã§ÌñâÏúºÎ°ú Îß§Î¨º Ï†ïÎ≥¥ ÏàòÏßë')
  }
}

// Ïã§Ìñâ
if (require.main === module) {
  const integration = new FullMolitIntegration()
  integration.run().catch(console.error)
}

module.exports = FullMolitIntegration